// file      : xsd/cxx/parser/options.cli
// author    : Boris Kolpackov <boris@codesynthesis.com>
// copyright : Copyright (c) 2005-2011 Code Synthesis Tools CC
// license   : GNU GPL v2 + exceptions; see accompanying LICENSE file

include <vector>;
include <string>;
include <cstddef>; // std::size_t

include <cult/types.hxx>; // NarrowString

include <cxx/options.cli>;

namespace CXX
{
  namespace Parser
  {
    class options: CXX::options
    {
      std::vector<Cult::Types::NarrowString> --type-map
      {
        "<mapfile>",
        "Read XML Schema to C++ type mapping information from <mapfile>.
         Repeat this option to specify several type maps. Type maps are
         considered in order of appearance and the first match is used. By
         default all user-defined types are mapped to \cb{void}. See the
         TYPE MAP section below for more information."
      };

      Cult::Types::NarrowString --xml-parser = "xerces"
      {
        "<parser>",
        "Use <parser> as the underlying XML parser. Valid values are
         \cb{xerces} for Xerces-C++ (default) and \cb{expat} for Expat."
      };

      // Features.
      //
      bool --generate-validation
      {
        "Generate validation code. The validation code (\"perfect parser\")
         ensures that instance documents conform to the schema. Validation
         code is generated by default when the selected underlying XML parser
         is non-validating (\cb{expat})."
      };

      bool --suppress-validation
      {
        "Suppress the generation of validation code. Validation is suppressed
         by default when the selected underlying XML parser is validating
         (\cb{xerces})."
      };

      bool --generate-polymorphic
      {
        "Generate polymorphism-aware code. Specify this option if you use
         substitution groups or \cb{xsi:type}."
      };

      bool --generate-noop-impl
      {
        "Generate a sample parser implementation that does nothing (no
         operation). The sample implementation can then be filled with
         the application-specific code. For an input file in the form
         \cb{name.xsd} this option triggers the generation of two
         additional C++ files in the form: \cb{name-pimpl.hxx} (parser
         implementation header file) and \cb{name-pimpl.cxx} (parser
         implementation source file)."
      };

      bool --generate-print-impl
      {
        "Generate a sample parser implementation that prints the XML data
         to \c{STDOUT}. For an input file in the form \cb{name.xsd} this
         option triggers the generation of two additional C++ files in the
         form: \cb{name-pimpl.hxx} (parser implementation header file) and
         \cb{name-pimpl.cxx} (parser implementation source file)."
      };

      bool --generate-test-driver
      {
        "Generate a test driver for the sample parser implementation. For an
         input file in the form \cb{name.xsd} this option triggers the
         generation of an additional C++ file in the form
         \cb{name-driver.cxx}."
      };

      bool --force-overwrite
      {
        "Force overwriting of the existing implementation and test driver
         files. Use this option only if you do not mind loosing the changes
         you have made in the sample implementation or test driver files."
      };

      // Root element.
      //
      bool --root-element-first
      {
        "Indicate that the first global element is the document root. This
         information is used to generate the test driver for the sample
         implementation."
      };

      bool --root-element-last
      {
        "Indicate that the last global element is the document root. This
         information is used to generate the test driver for the sample
         implementation."
      };

      Cult::Types::NarrowString --root-element
      {
        "<element>",
        "Indicate that <element> is the document root. This information is
         used to generate the test driver for the sample implementation."
      };

      // Suffixes.
      //
      Cult::Types::NarrowString --skel-type-suffix = "_pskel"
      {
        "<suffix>",
        "Use the provided <suffix> instead of the default \cb{_pskel} to
         construct the names of the generated parser skeletons."
      };

      Cult::Types::NarrowString --skel-file-suffix = "-pskel"
      {
        "<suffix>",
        "Use the provided <suffix> instead of the default \cb{-pskel} to
         construct the names of the generated parser skeleton files."
      };

      Cult::Types::NarrowString --impl-type-suffix = "_pimpl"
      {
        "<suffix>",
        "Use the provided <suffix> instead of the default \cb{_pimpl} to
         construct the names of the parser implementations for the built-in
         XML Schema types as well as sample parser implementations."
      };

      Cult::Types::NarrowString --impl-file-suffix = "-pimpl"
      {
        "<suffix>",
        "Use the provided <suffix> instead of the default \cb{-pimpl} to
         construct the names of the generated sample parser implementation
         files."
      };
    };
  }
}
